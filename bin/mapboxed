#!/usr/bin/env node
const readline = require('readline');
const commander = require('commander');
const path = require('path');
const fs = require('fs');
const rimraf = require('rimraf');
const axios = require('axios');
const sharp = require('sharp');
const glob = require('glob');

commander
  .version(require('../package.json').version)
  .usage('[options]')
  .description('Downloads the tiles from mapbox and stitches them together')
  .requiredOption('-z, --zoom <zoom>', 'zoom level')
  .requiredOption('-x1 <x1>', 'left longitude boundary')
  .requiredOption('-x2 <x2>', 'right longitude boundary')
  .requiredOption('-y1 <y1>', 'top latitude boundary')
  .requiredOption('-y2 <y2>', 'bottom latitude boundary')
  .option('-o, --outfile <outfile>', 'output filename', 'mapboxed.jpg')
  .option('-t, --tileset <tileset>', 'mapbox tileset id', 'mapbox.satellite')
  .option('-k, --key <token>', 'mapbox token (will override read from MAPBOX_TOKEN)')
  .option('-f, --format <format>', 'image format to download (jpg90 | jpg80 | jpg70 | png256 | png128 | png64 | png32 | png)', 'jpg90')
  .option('-p, --parallel <parallel>', 'Number of parallel connection to make to mapbox', '5')
  .option('-r, --res2x', 'fetch @2x size resolution')
  .option('-s, --silent', 'do not confirm download size')
  .option('-c, --cache', 'keep and read from temp tile files in .mapboxed')
  .parse(process.argv);

// TODO verify

// zoom level n function
const n = Math.pow(2, zoom);

// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Lon..2Flat._to_tile_numbers
// Convert lat / long to tile location
const deg2num = (latDeg, lonDeg) => {
  const latRad = latDeg * Math.PI / 180;
  const xtile = Math.floor(n * ((lonDeg + 180) / 360));
  const ytile = Math.floor(n * (1 - (Math.asinh(Math.tan(latRad))) / Math.PI) / 2);
  return [xtile, ytile];
};

const num2deg = (x, y) => {
  const lonDeg = x / n * 360 - 180;
  const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  const latDeg = latRad * (180 / Math.PI);
  return [lonDeg, latDeg];
};

// Get an array of all the tiles we will need.
let xTiles; let yTiles; let min; let
  max;
const layerTiles = (() => {
  let tiles = [];
  min = deg2num(layerBounds[1], layerBounds[0]);
  max = deg2num(layerBounds[3], layerBounds[2]);
  const xRange = [min[0], max[0]].sort();
  const yRange = [min[1], max[1]].sort();
  xTiles = xRange[1] - xRange[0];
  yTiles = yRange[1] - yRange[0];
  for (let x = xRange[0]; x <= xRange[1]; x++) {
    for (let y = yRange[0]; y <= yRange[1]; y++) {
      tiles = tiles.concat([[x, y]]);
    }
  }
  return tiles;
})();

// Check cached variant
let toDownload = layerTiles;
if (commander.cache) {
  // Search for files within the .mapboxed cache directory
  glob('./.mapboxed/**/*', {}, (err, files) => {
    if (err) {
      console.error(err);
      process.exit(1);
    }
    toDownload = toDownload.filter(
      ([x, y]) => files.indexOf(
        `./.mapboxed/${zoom}/${tileset_id}-${x}-${y}${commander.res2x ? '@2x' : ''}.${format.replace(/[0-9]/g, '')}`,
      ) < 0,
    );
  });
}

// Mapbox API URL
const url = (x, y) => `https://api.mapbox.com/v4/${tileset_id}/${zoom}/${x}/${y}${commander.res2x ? '@2x' : ''}.${format}?access_token=${MAPBOX_TOKEN}`;

// Download this tile
const downloadTile = async (x, y) => {
  const tileURL = url(x, y);
  const imagesDir = path.resolve('./.mapboxed');
  if (!fs.existsSync(imagesDir)) fs.mkdirSync(imagesDir);
  const zoomDir = path.resolve(imagesDir, `${zoom}`);
  if (!fs.existsSync(zoomDir)) fs.mkdirSync(zoomDir);
  const tilePath = path.resolve(zoomDir, `${tileset_id}-${x}-${y}${commander.res2x ? '@2x' : ''}.${format.replace(/[0-9]/g, '')}`);
  const writer = fs.createWriteStream(tilePath);

  const response = await axios({ url: tileURL, method: 'GET', responseType: 'stream' });
  response.data.pipe(writer);

  return new Promise((resolve, reject) => {
    writer.on('finish', resolve);
    writer.on('error', reject);
  });
};

// Warn and continue
// TODO silent option or cached and we have nothing to download
console.warn(`This will download ${toDownload.length} tiles from the mapbox API. Are you sure you want to continue? (Y/N)`);

// Create readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

// Listen for yes
rl.on('line', (line) => {
  rl.close();
  if (!line || line.charAt(0).toUpperCase() === 'Y') {
    (async () => {
      // TODO batch
      for (let i = 0; i < toDownload.length; i++) {
        const [x, y] = toDownload[i];

        process.stdout.write(`downloading file ${i + 1} of ${toDownload.length} [z:${zoom} x:${x} y:${y}]... `);
        try {
          await downloadTile(x, y);
        } catch (e) {
          console.error('failed:', e);
          process.exit(1);
        }
        console.log('success');
      }

      // Print generated lat/lng bounds
      console.log(`Generated satellite image boundingbox: [${[...num2deg(...min), ...num2deg(...max.map((d) => d + 1))].join(', ')}]`);

      // Assemble image
      const [baseX, baseY] = layerTiles[0];
      const imgPath = (x, y) => `./.mapboxed/${zoom}/${tileset_id}-${x}-${y}${commander.res2x ? '@2x' : ''}.${format.replace(/[0-9]/g, '')}`;
      console.log('compiling image...');

      // Generate format options
      const formatOptions = {};
      switch (format.replace(/[0-9]/g, '')) {
        case 'jpg':
          formatOptions.quality = parseInt(format.replace(/[a-z]/g, ''));
          break;
        case 'png':
          formatOptions.colors = parseInt(format.replace(/[a-z]/g, '') || '256');
          break;
        default:
          break;
      }

      let composited = sharp(imgPath(...layerTiles[0]))
        .extend({
          top: 0,
          left: 0,
          bottom: yTiles * (commander.res2x ? 512 : 256),
          right: xTiles * (commander.res2x ? 512 : 256),
          background: {
            r: 0, g: 0, b: 0, alpha: 0,
          },
        });

      const restTiles = layerTiles.slice(1);

      // Janky nested raw().toBuffer() loop in chunks of 4 because of
      // https://github.com/lovell/sharp/issues/2286
      await composited.raw().toBuffer(async (err, buffer, info) => {
        for (let i = 0; i < restTiles.length; i++) {
          const buffer = await composited.raw().toBuffer();
          composited = sharp(buffer, { raw: info })
            .composite([{
              input: imgPath(...restTiles[i]),
              left: (restTiles[i][0] - baseX) * (commander.res2x ? 512 : 256),
              top: (restTiles[i][1] - baseY) * (commander.res2x ? 512 : 256),
            }]);
        }
        // Set quality
        await composited
          .toFormat(format.replace(/[0-9]/g, ''), formatOptions)
          .toFile(commander.outfile);

        // Delete cache
        if (!commander.cache) rimraf.sync('./.mapboxed');

        // Done
        console.log(`Satellite Image saved to ${commander.outfile}`);
      });
    })();
  } else process.exit();
});
