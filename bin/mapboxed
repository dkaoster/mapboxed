#!/usr/bin/env node
const readline = require('readline');
const commander = require('commander');
const rimraf = require('rimraf');
const glob = require('glob');

// Import compiled mapboxed tools
const mapboxed = require('../dist/mapboxed.cjs');

commander
  .version(require('../package.json').version)
  .usage('[options]')
  .description('Downloads the tiles from mapbox and stitches them together')
  .requiredOption('-z, --zoom <zoom>', 'zoom level')
  .requiredOption('-x1 <x1>', 'left longitude boundary')
  .requiredOption('-x2 <x2>', 'right longitude boundary')
  .requiredOption('-y1 <y1>', 'top latitude boundary')
  .requiredOption('-y2 <y2>', 'bottom latitude boundary')
  .option('-o, --outfile <outfile>', 'output filename', 'mapboxed.jpg')
  .option('-t, --tileset <tileset>', 'mapbox tileset id', 'mapbox.satellite')
  .option('-k, --key <token>', 'mapbox token (will override read from MAPBOX_TOKEN environment variable)')
  .option('-f, --format <format>', 'image format to download (jpg90 | jpg80 | jpg70 | png256 | png128 | png64 | png32 | png)', 'jpg90')
  .option('-p, --parallel <parallel>', 'Number of parallel connection to make to mapbox', '5')
  .option('-r, --res2x', 'fetch @2x size resolution')
  .option('-s, --silent', 'do not confirm download size')
  .option('-c, --cache', 'keep and read from temp tile files in .mapboxed')
  .parse(process.argv);

// params for this script
let params;

// Mapboxed param validation
try {
  params = mapboxed.validateParams(commander);
} catch (e) {
  console.error(e);
  process.exit(1);
}

// Get an array of all the tiles we will need.
const { tiles, min, max, xTilesLength, yTilesLength } = mapboxed.generateTiles(params);

// Check cached variant
let toDownload = tiles;
if (commander.cache) {
  // Search for files within the .mapboxed cache directory
  glob('./.mapboxed/**/*', {}, (err, files) => {
    if (err) {
      console.error(err);
      process.exit(1);
    }
    toDownload = toDownload.filter(([x, y]) => files.indexOf(mapboxed.imgPath(params, x, y)) < 0);
  });
}

// Warn and continue
// TODO silent option or cached and we have nothing to download
console.warn(`This will download ${toDownload.length} tiles from the mapbox API. Are you sure you want to continue? (Y/N)`);

// Create readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

// Listen for yes
rl.on('line', (line) => {
  rl.close();
  if (!line || line.charAt(0).toUpperCase() === 'Y') {
    (async () => {
      for (let i = 0; i < toDownload.length; i += params.parallel) {

      }

      // TODO batch
      for (let i = 0; i < toDownload.length; i++) {
        const [x, y] = toDownload[i];

        process.stdout.write(`downloading file ${i + 1} of ${toDownload.length} [z:${zoom} x:${x} y:${y}]... `);
        try {
          // eslint-disable-next-line no-await-in-loop
          await mapboxed.downloadTile(params, x, y);
        } catch (e) {
          console.error('failed:', e);
          process.exit(1);
        }
        console.log('success');
      }

      // Print generated lat/lng bounds
      console.log(`Generated satellite image boundingbox: [${
        [...mapboxed.num2deg(...min), ...mapboxed.num2deg(...max.map((d) => d + 1))].join(', ')
      }]`);

      console.log('compiling image...');

      await mapboxed
        .generateImage(params, tiles, xTilesLength, yTilesLength)
        .toFile(commander.outfile);

      // Delete cache
      if (!commander.cache) rimraf.sync('./.mapboxed');

      // Done
      console.log(`Satellite Image saved to ${commander.outfile}`);
    })();
  } else process.exit();
});
